// Generated by CoffeeScript 2.6.1
// * Класс оболочка навыка на карте (т.е. когда навык уже "запущен")
// * Содержит методы обработки урона, целей и прочие механики работы АБС навыка

//@[STORABLE]
var AASkill2MapAction;

AASkill2MapAction = class AASkill2MapAction {
  constructor(aaSkill, subject, point) {
    this.aaSkill = aaSkill;
    // * Эти значения меняются из Sprite_AAMapSkill2Projectile
    this.x = 0;
    this.y = 0;
    this.totalFlyTime = this._calculateFlyTime();
    this.setSubject(subject);
    this.setTargetPoint(point);
    if (AA.Network.isNetworkGame() && !this.isPhantom()) {
      // * Сгенерировать новый уникальный ID для сети
      this.setUniqueId();
    }
    return;
  }

  setSubject(subject) {
    this.packedSubject = null;
    if (!subject.isABS()) {
      return;
    }
    this.packedSubject = AA.Utils.packAAEntity(subject);
    this._initStartPoint();
  }

  // * Уникальный ID для сетевой игры, чтобы можнобыло найти конкретный Projectile
  // * из запроса от сервера (завершить Projectile например)
  setUniqueId(uniqueId) {
    if (uniqueId == null) {
      return this.uniqueId = KDCore.makeid(6) + "_" + this.aaSkill.idA;
    } else {
      return this.uniqueId = uniqueId;
    }
  }

  // * Данный навык обрабатвается на мастере карты
  // * Просчёт коллизий на данном клиенте должен быть отключён
  isPhantom() {
    return AA.Network.isNetworkGame() && !ANGameManager.isMapMaster();
  }

  setTargetPoint(point) {
    if (this.packedSubject != null) {
      point = this.preparePoint(point);
    }
    if (point instanceof Game_Character) {
      point = point.toPoint();
    }
    // * Точки на экране
    this.scX = this._convertPointValue(point.x);
    this.scY = this._convertPointValue(point.y);
    // * Точки на карте
    this.tX = point.x;
    this.tY = point.y;
  }

  preparePoint(point) {
    var direction, subject;
    if (this.aaSkill.isInPoint()) {
      return point;
    } else {
      // * По направлению персонажа (face direction)
      subject = this.getSubject();
      if ((subject._diagonalDir != null) && subject._diagonalDir !== false) {
        direction = subject._diagonalDir;
      } else {
        direction = subject.direction();
      }
      return AA.Utils.Math.getProjectilePointByDirection(subject.toPoint(), direction);
    }
  }

  //TODO: Если будет Friendly Fire или PVP, то поменять
  isSubjectIsPlayer() {
    return (this.packedSubject != null) && this.packedSubject.type === 0;
  }

  isSubjectIsNetChar() {
    return AA.Network.isNetworkGame() && this.isSubjectIsPlayer() && this.packedSubject.id !== ANNetwork.myId();
  }

  isSubjectIsAlly() {
    return (this.packedSubject != null) && this.packedSubject.type === 2;
  }

  isSubjectIsEvent() {
    return (this.packedSubject != null) && this.packedSubject.type === 1;
  }

  getSubjectEvId() {
    if (this.isSubjectIsEvent()) {
      return this.packedSubject.id;
    } else {
      return -1;
    }
  }

  getSubject() {
    return AA.Utils.unpackAAEntity(this.packedSubject);
  }

  id() {
    return this.aaSkill.idA;
  }

  zLevel() {
    return this.aaSkill.z;
  }

  image() {
    return this.aaSkill.skillImg;
  }

  hitOffset() {
    return this.aaSkill.hitOffset;
  }

  speed() {
    return this.aaSkill.speed;
  }

  isHaveRegion(regionId) {
    var globalRegions;
    globalRegions = AA.PP.getProjectileRestrictedRegions();
    if (globalRegions.contains(regionId)) {
      return true;
    }
    return this.aaSkill.noPassRegions.contains(regionId);
  }

  isHaveTerrain(terrainTag) {
    var globalTerrains;
    globalTerrains = AA.PP.getProjectileRestrictedTerrains();
    if (globalTerrains.contains(terrainTag)) {
      return true;
    }
    return this.aaSkill.noPassTerrains.contains(terrainTag);
  }

  isCanHitPoint() {
    return this.aaSkill.isInCertainPoint();
  }

  isNoContact() {
    return this.aaSkill.isNoContact();
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ AASkill2MapAction.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AASkill2MapAction.prototype;
  _._initStartPoint = function() {
    var subject;
    subject = this.getSubject();
    this.x = this._convertPointValue(subject.x);
    this.y = this._convertPointValue(subject.y);
  };
  // * Приводим обе точки (старт и финишь) к одному формату
  _._convertPointValue = function(value) {
    var tw;
    tw = $gameMap.tileWidth();
    return Number(value * tw + tw / 2);
  };
  
  // * Дистанцию полёта определяем по времени, а не по дистанции
  _._calculateFlyTime = function() {
    var dist;
    if (this.aaSkill.range <= 0 || this.speed() <= 0) {
      return 10;
    } else {
      dist = this.aaSkill.range * $gameMap.tileWidth() + $gameMap.tileWidth() / 2;
      return dist / this.speed();
    }
  };
})();

// ■ END AASkill2MapAction.coffee
//---------------------------------------------------------------------------
