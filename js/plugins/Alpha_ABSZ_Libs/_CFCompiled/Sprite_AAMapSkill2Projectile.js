// Generated by CoffeeScript 2.6.1
var Sprite_AAMapSkill2Projectile;

Sprite_AAMapSkill2Projectile = class Sprite_AAMapSkill2Projectile extends Sprite {
  constructor(mapIndex) {
    super();
    this.mapIndex = mapIndex;
    this.skill = $gameMap.aaMapSkills()[this.mapIndex];
    this._id = this.skill.id();
    this._ended = false;
    this._hasHit = false;
    this._initParams();
    this._setupImage();
    this._setupDirection();
    this._collisionDetectionThread = new KDCore.TimedUpdate(2, this._checkCollision.bind(this));
    this._updatePosition();
    if (this._frames != null) {
      this._updateFrame();
    }
    return;
  }

  // * Навыв завершён (достиг цели или расстояния)
  isEnd() {
    return this._ended === true;
  }

  update() {
    super.update();
    this._updatePosition();
    if (this._frames != null) {
      this._updateFrame();
    }
    if (this._hasHit === true) {
      // * Зануляем принудительно, если достиг цели
      this.skill.totalFlyTime = 0;
    } else {
      this._updateMove();
      this._collisionDetectionThread.update();
      this.skill.totalFlyTime -= 1;
    }
    this._updateEnd();
  }

};

(function() {  
  //TODO: СИСТЕМАТИЗАЦИЯ И КОММЕНТАРИИ

  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ Sprite_AAMapSkill2Projectile.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = Sprite_AAMapSkill2Projectile.prototype;
  _._initParams = function() {
    this._framesBeforeStartFadeToEnd = 5;
    // * FROM START SUBJECT OFFSET ?
    //TODO: С события можно считать (с врага), а с игрока как?
    this._yOffset = 0;
    // * Получается всегда, так как навыки могут только персонажи использовать
    this._yOffsetChar = false; //always? #@skill.isCharPoint
    this.anchor.x = 0.5;
    this.anchor.y = 0.5;
    this.z = this.skill.zLevel();
    this._hitDist = this.skill.hitOffset();
  };
  _._setupImage = function() {
    this._setupAnimatedImg();
    this.bitmap = ImageManager.loadPicture(this.skill.image());
  };
  _._setupAnimatedImg = function() {
    var frames;
    this._curFrame = 0;
    this._frameTimer = 0;
    frames = this.skill.image().match(/\((.*)\)/i);
    if (frames != null) {
      frames = frames[1].split(',');
      this._frames = Number(frames[0]);
      this._frameSpeed = Number(frames[1]);
    }
  };
  _._setupDirection = function() {
    var eX, eY, sX, sY, yo;
    //yo = if @_yOffset and @_yOffsetChar then @_yOffset / 48 else 0
    yo = 0;
    eX = this.skill.scX;
    eY = this.skill.scY;
    sX = this.skill.x;
    sY = this.skill.y;
    this._angle = Math.atan2(eY - yo - sY, eX - sX) * 180 / Math.PI;
    //pi = Math.PI / 180
    //TODO: pi
    this.rotation = (this._angle + 90) * Math.PI / 180;
    this.dx = this.skill.speed() * Math.cos(this._angle * Math.PI / 180);
    this.dy = this.skill.speed() * Math.sin(this._angle * Math.PI / 180);
  };
  _._updatePosition = function() {
    this.x = this.skill.x - $gameMap.displayX() * $gameMap.tileWidth();
    this.y = this.skill.y - $gameMap.displayY() * $gameMap.tileWidth() + this._yOffset;
  };
  _._updateMove = function() {
    this.skill.x += this.dx;
    this.skill.y += this.dy;
  };
  _._updateFrame = function() {
    var ph, pw, sx, sy;
    pw = this.bitmap.width / this._frames;
    ph = this.bitmap.height;
    sx = this._curFrame * pw;
    sy = 0;
    if (this._frameTimer >= this._frameSpeed) {
      this._frameTimer = 0;
      this._curFrame = this._curFrame >= this._frames - 1 ? 0 : this._curFrame + 1;
    }
    this.setFrame(sx, sy, pw, ph);
    this._frameTimer += 1;
  };
  _._updateEnd = function() {
    if (this.skill.totalFlyTime > 0) {
      return;
    }
    if (this._framesBeforeStartFadeToEnd < 0) {
      this.opacity -= 40;
      if (this.opacity <= 0) {
        return this._onTimeEnded();
      }
    } else {
      return this._framesBeforeStartFadeToEnd -= 1;
    }
  };
  _._onTimeEnded = function() {
    var x, y;
    this._ended = true;
    // * Если навык без контактный и его "время" закончено, он должен сработать всё равно
    if (this._hasHit === false && this.skill.isNoContact() && !this.skill.isPhantom()) {
      x = Math.floor(this.skill.x / $gameMap.tileWidth());
      y = Math.floor(this.skill.y / $gameMap.tileWidth());
      this.onHit({x, y});
    }
    AA.EV.call("MapSkillsRequestsClean");
  };
  _._checkCollision = function() {
    var event, map, playerHit, point, x, y;
    if (this.skill.isPhantom()) {
      return;
    }
    if (this.opacity < 255) {
      return;
    }
    playerHit = this._checkHitPlayer();
    if (playerHit === true) {
      "PLAYER HIT".p();
      this.onHit($gamePlayer);
      return;
    }
    // * Для оптимизации, считаем один раз тут, а не в каждом методе
    x = Math.floor(this.skill.x / $gameMap.tileWidth());
    y = Math.floor(this.skill.y / $gameMap.tileWidth());
    map = this._checkHitMap(x, y);
    if (map === true) {
      "MAP OBSTCL HIT".p();
      this.onHit({x, y});
      return;
    }
    point = this._checkHitPoint(x, y);
    if (point === true) {
      "POINT HIT".p();
      this.onHit({x, y});
      return;
    }
    event = this._checkHitEvent();
    if (event != null) {
      "EVENT HIT".p();
      this.onHit(event);
    }
  };
  // * Когда достиг игрока
  _._checkHitPlayer = function() {
    var dist;
    if (this.skill.isSubjectIsPlayer()) {
      //TODO: friendlyfier is 1
      return false;
    }
    dist = AATargetsManager.getScreenExtDistance($gamePlayer, $gameTemp.aaProjYOff, this.x, this.y);
    return dist < this._hitDist && this.isSameMapLevel($gamePlayer._priorityType);
  };
  // * Когда достиг точки на карте (указанной как цель)
  _._checkHitPoint = function(tx, ty) {
    if (!this.skill.isCanHitPoint()) {
      return false;
    }
    return this.skill.tX === tx && this.skill.tY === ty;
  };
  // * Когда препятсвие на карте (Регион или Terrain)
  _._checkHitMap = function(tx, ty) {
    return this.skill.isHaveRegion($gameMap.regionId(tx, ty)) || this.skill.isHaveTerrain($gameMap.terrainTag(tx, ty));
  };
  // * Когда достиг события
  _._checkHitEvent = function() {
    var dist, ev, i, len, ref, subId;
    subId = this.skill.getSubjectEvId();
    ref = $gameMap.events();
    for (i = 0, len = ref.length; i < len; i++) {
      ev = ref[i];
      if (ev == null) {
        continue;
      }
      if (ev.eventId() === subId) {
        // * В себя нельзя попасть
        continue;
      }
      dist = AATargetsManager.getScreenExtDistance(ev, $gameTemp.aaProjYOff, this.x, this.y);
      if (dist < this._hitDist && this.isEventIsObstacle(ev)) {
        return ev;
      }
    }
    return null;
  };
  _.isSameMapLevel = function(priorityType) {
    if (this.z <= 2) {
      // * Ниже персонажей
      return priorityType === 0;
    }
    if (this.z <= 4) {
      // * На одном уровне
      return priorityType === 1;
    }
    // * Выше
    return priorityType === 3;
  };
  // * Блокирует ли событие Projectile ?
  _.isEventIsObstacle = function(event) {
    if (event._erased) {
      return false;
    }
    if (event.isThrough()) {
      return false;
    }
    if (event._aaMapSkillVectorBlockList == null) {
      return this.isSameMapLevel(event._priorityType);
    } else {
      if (event._aaMapSkillVectorBlockList.isEmpty()) {
        return false;
      }
      return !event._aaMapSkillVectorBlockList.contains(this.skill.id());
    }
  };
  _.onHit = function(target) {
    this._hasHit = true;
    this.opacity = 0;
    "HIT".p();
    console.info(target);
    AABattleActionsManager.applySkillAction(this.skill.getSubject(), target, this.skill.aaSkill);
    // * Vector On Hit Actions работают отдельно, не в AABattleActionsManager
    if (target instanceof Game_Event) {
      target.aaOnVectorHit(this.skill.id());
    }
    if (!this.skill.isPhantom()) {
      AANetworkManager.endAASkillOnMap(this.skill.uniqueId);
    }
  };
})();

// ■ END Sprite_AAMapSkill2Projectile.coffee
//---------------------------------------------------------------------------
