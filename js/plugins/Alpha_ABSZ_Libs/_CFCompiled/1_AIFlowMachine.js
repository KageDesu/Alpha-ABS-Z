// Generated by CoffeeScript 2.6.1
// * Машина состояний для АИ
//@[STORABLE]
var AIFlowMachine;

AIFlowMachine = class AIFlowMachine {
  constructor(id) {
    this.id = id;
    this.state = 0;
    this.prevState = -1;
    this._stateFlows = [];
    this._setup();
    if (AA.Network.isNetworkGame()) {
      this._setupForNetwork();
    }
    return;
  }

  registerFlowForState(stateId, flowObject) {
    return this._stateFlows[stateId] = flowObject;
  }

  char() {
    return $gameMap.event(this.id);
  }

  entity() {
    return this.char().AAEntity();
  }

  battler() {
    return this.char().AABattler();
  }

  isActive() {
    return this.char().isActive();
  }

  logic() {
    return this.char().AALogic();
  }

  model() {
    return this.char().AAModel();
  }

  // * Сбросить состояние
  resetState() {
    return this.setState(0);
  }

  // * Установить состояние
  setState(newState) {
    // * Предыдущее состояние
    this.prevState = this.state;
    // * Текущее состояние (новое)
    this.state = newState;
    this._onStateChanged();
  }

  // * Перейти в состояние (без сброса данных, плавно)
  translateToState(newState) {
    this.prevState = this.state;
    this.state = newState;
    this._onStateTranslated();
  }

  update() {
    if (this.char() == null) {
      return;
    }
    if (!this.isActive()) {
      return;
    }
    // * Логика состояний работает только на мастере карты
    if (AA.Network.isNetworkGame() && !ANGameManager.isMapMaster()) {
      return;
    }
    this._updateStates();
    this._updateForNetwork();
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ AIFlowMachine.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AIFlowMachine.prototype;
  _._setup = function() {}; // * EMPTY
  _._setupForNetwork = function() {
    // * Сетевые методы вынесенны отдельно
    this._createNetworkObserver();
  };
  _._updateStates = function() {
    if (this.state < 0) {
      return;
    }
    if (this._stateFlows.length === 0) {
      return;
    }
    return this._stateFlows[this.state].update();
  };
  _._onStateChanged = function() {
    if (this.prevState >= 0) {
      this._stateFlows[this.prevState].onStateEnd();
    }
    this._stateFlows[this.state].onStateStart();
  };
  _._onStateTranslated = function() {
    if (this.prevState >= 0) {
      this._stateFlows[this.prevState].onStatePause();
    }
    this._stateFlows[this.state].onStateResume(this.prevState);
  };
  _._updateForNetwork = function() {
    return this._updateDataObserver();
  };
})();

// ■ END AIFlowMachine.coffee
//---------------------------------------------------------------------------
