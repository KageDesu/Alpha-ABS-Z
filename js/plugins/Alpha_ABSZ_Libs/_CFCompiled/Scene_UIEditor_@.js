// Generated by CoffeeScript 2.5.1
// * Сцена игрового визуального редактора интерфейса
(function() {
  var Scene_UIEditor;
  Scene_UIEditor = class Scene_UIEditor extends Scene_Base {
    constructor() {
      super();
      this.elementUnderMouse = null;
      this.isDrag = false;
      this.preEditElementsStates = [];
      return;
    }

    create() {
      super.create();
      // * Запоминаем состояние АБС, так как надо его ставить на паузу
      $gameTemp._needRestoreABSSystemAfterUIEdit = AA.isABSActive();
      AA.System.pauseABS();
      this.createMain(); //# -> 0
      //TODO: Добавить опцию (Показывать ли скрытые в редактре...)
      this.showNotVisibleElements();
      //TODO: Добавить опцию (параметр  Показывать ли..)
      return this.showNotEditableElements();
    }

    // * Элементы, которые нельзя редактировать, мы отмечаем (блюр)
    showNotEditableElements() {
      var e, i, len, ref;
      ref = this.elements();
      for (i = 0, len = ref.length; i < len; i++) {
        e = ref[i];
        if (!e.isCanBeEdited()) {
          this.deactivateElement(e);
        }
      }
    }

    // * Элемнты, которые скрыты, мы показываем прозрачными
    showNotVisibleElements() {
      var e, i, len, ref;
      ref = this.elements();
      for (i = 0, len = ref.length; i < len; i++) {
        e = ref[i];
        if (!e.visible) {
          // * Тут проверяется по флагу visible, а не isActive
          this.transparentElement(e);
        }
      }
    }

    deactivateElement(element) {
      // * Сохраняем значения перед редактированием
      this.preEditElementsStates.push([element, element.visible, element.opacity]);
      element.opacity = 150;
      element.desaturate();
    }

    transparentElement(element) {
      this.preEditElementsStates.push([element, element.visible, element.opacity]);
      element.visible = true;
      element.opacity = 120;
    }

    // * Сбросить значения по умолчанию
    resetElement(element) {
      var user;
      element.reset("position");
      user = $gameSystem.aaGetUserUISettings();
      return user.set(element.tag, "resetPosition");
    }

    // * Сохранить позицию элемента
    saveElementPosition(element) {
      var user, x, y;
      user = $gameSystem.aaGetUserUISettings();
      ({x, y} = element);
      user.set(element.tag, "setPosition", [x, y]);
    }

    elements() {
      return this.uiSpriteset.elements;
    }

    //TODO: Добавить кнопка H - скрыть\показать или скрыть \ показать последний (если не на элементе курсор)
    // Например стоит опция не показывать скрытые

      //TODO: Параметр плагина - OFF, Всегда, Только в режиме разработки

      //TODO: Кнопка - Сбросить до последний позиции???
    update() {
      super.update();
      this.updateMain(); //# -> Mouse
      this.updateExit();
      if (!this.isDrag) {
        // * Обновляем пользовательское управление (если не Drag)
        return this.updateInput();
      }
    }

    updateExit() {
      if (Input.isCancel()) {
        return this.popScene();
      }
    }

    updateInput() {
      // * Сброс позиции по умолчанию
      if (Input.isTriggered('r')) {
        if (this.elementUnderMouse != null) {
          this.resetElement(this.elementUnderMouse);
        }
      }
    }

    stop() {
      var elementData, i, len, ref;
      super.stop();
      if ($gameTemp._needRestoreABSSystemAfterUIEdit === true) {
        AA.System.resumeABS();
      }
      ref = this.preEditElementsStates;
      // * Восстанавливаем прозрачность и видимость которые были перед редактированием
      for (i = 0, len = ref.length; i < len; i++) {
        elementData = ref[i];
        elementData[0].visible = elementData[1];
        elementData[0].opacity = elementData[2];
      }
    }

  };
  AA.link(Scene_UIEditor);
})();
