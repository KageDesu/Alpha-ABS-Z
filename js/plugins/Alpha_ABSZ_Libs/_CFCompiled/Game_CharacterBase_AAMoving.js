// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_CharacterBase.prototype;
  _.distTo = function(point) {
    return $gameMap.distance(this.x, this.y, point.x, point.y);
  };
  _.aaGetOtherDiagDirection = function(horz, vert) {
    if (this.canPass(this._x, this._y, horz)) {
      return horz;
    } else {
      return vert;
    }
  };
  // * Находится ли на Х расстоянии к точке
  _.aaIsNearThePoint = function(point, minDist = 1) {
    var e, sx, sy;
    try {
      sx = Math.abs(this.deltaXFrom(point.x));
      sy = Math.abs(this.deltaYFrom(point.y));
      return (sx + sy) <= minDist;
    } catch (error) {
      e = error;
      AA.w;
      return false;
    }
  };
  // * Двигаться к цели
  _.aaMoveTypeToTarget = function() {
    var e, target;
    try {
      target = this.AAEntity().getTarget();
      if (!this.aaIsNearThePoint(target)) {
        return this.aaMoveTypeToPoint(target);
      } else {
        return this.aaTurnTowardTarget();
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * ОСНОВНОЙ метод
  // * Движение к точке карты
  _.aaMoveTypeToPoint = function(point) {
    var direction, e, horz, vert;
    try {
      if (point == null) {
        return;
      }
      if (AA.Input.IsDiagonal === true) {
        direction = this.aaFindDirectionToDiagonal(point.x, point.y);
        if (direction % 2 === 0) {
          return this.aaMoveToPointStraight(point);
        } else if (Math.abs(direction % 2) === 1) {
          [horz, vert] = AA.Utils.get8Dir(direction);
          this.moveDiagonally(horz, vert);
          //TODO: В ANETZ до версии 0.7 нет автосинхронизации диагонального движения
          //TODO: УБРАТЬ ЭТО ПОТОМ!!
          if (AA.Network.isNetworkGame()) {
            if (this instanceof Game_Event) {
              if (ANET.Version < 70) {
                return ANMapManager.sendEventMove(this.eventId());
              }
            }
          }
        }
      } else {
        return this.aaMoveToPointStraight(point);
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * Движение к точки (4 way only)
  _.aaMoveToPointStraight = function(point) {
    var dir;
    if (point == null) {
      return;
    }
    dir = this.findDirectionTo(point.x, point.y);
    if (dir > 0) {
      this.moveStraight(dir);
    }
  };
  
  // * Повернуться к цели
  _.aaTurnTowardTarget = function() {
    var e, target;
    try {
      target = this.AAEntity().getTarget();
      if (target == null) {
        return;
      }
      this.turnTowardCharacter(target);
      // * Дополнительно синхронизируем поворот к цели
      // * (сама цель уже синхронизирована у события)
      if (AA.Network.isNetworkGame()) {
        return AANetworkManager.sendTurnTowardTarget(this);
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * Поиск пути (диагональное движение)
  _.aaFindDirectionToDiagonal = function(goalX, goalY) {
    var best, bestIndex, closedList, current, deltaX1, deltaX2, deltaY1, deltaY2, diag, direction, g1, g2, goaled, horz, i, index2, j, mapWidth, neighbor, node, nodeList, openList, pos1, pos2, searchLimit, start, vert, x1, x2, y1, y2;
    searchLimit = this.searchLimit();
    mapWidth = $gameMap.width();
    nodeList = [];
    openList = [];
    closedList = [];
    start = {};
    best = start;
    if (this.x === goalX && this.y === goalY) {
      return 0;
    }
    start.parent = null;
    start.x = this.x;
    start.y = this.y;
    start.g = 0;
    start.f = $gameMap.distance(start.x, start.y, goalX, goalY);
    nodeList.push(start);
    openList.push(start.y * mapWidth + start.x);
    while (nodeList.length > 0) {
      bestIndex = 0;
      i = 0;
      while (i < nodeList.length) {
        if (nodeList[i].f < nodeList[bestIndex].f) {
          bestIndex = i;
        }
        i++;
      }
      current = nodeList[bestIndex];
      x1 = current.x;
      y1 = current.y;
      pos1 = y1 * mapWidth + x1;
      g1 = current.g;
      nodeList.splice(bestIndex, 1);
      openList.splice(openList.indexOf(pos1), 1);
      closedList.push(pos1);
      if (current.x === goalX && current.y === goalY) {
        best = current;
        goaled = true;
        break;
      }
      if (g1 >= searchLimit) {
        continue;
      }
      j = 0;
      while (j < 9) {
        direction = 1 + j;
        if (direction === 5) {
          j++;
          continue;
        }
        diag = Math.abs(direction % 2) === 1;
        [horz, vert] = AA.Utils.get8Dir(direction);
        if (diag && this.canPassDiagonally(x1, y1, horz, vert) && (this.canPass(x1, y1, horz) || this.canPass(x1, y1, vert))) {
          x2 = $gameMap.roundXWithDirection(x1, horz);
          y2 = $gameMap.roundYWithDirection(y1, vert);
        } else if (this.canPass(x1, y1, direction)) {
          x2 = $gameMap.roundXWithDirection(x1, direction);
          y2 = $gameMap.roundYWithDirection(y1, direction);
        } else {
          j++;
          continue;
        }
        pos2 = y2 * mapWidth + x2;
        if (closedList.contains(pos2)) {
          j++;
          continue;
        }
        g2 = g1 + 1;
        index2 = openList.indexOf(pos2);
        if (index2 < 0 || g2 < nodeList[index2].g) {
          if (index2 >= 0) {
            neighbor = nodeList[index2];
          } else {
            neighbor = {};
            nodeList.push(neighbor);
            openList.push(pos2);
          }
          neighbor.parent = current;
          neighbor.x = x2;
          neighbor.y = y2;
          neighbor.g = g2;
          neighbor.f = g2 + $gameMap.distance(x2, y2, goalX, goalY);
          if (!best || neighbor.f - neighbor.g < best.f - best.g) {
            best = neighbor;
          }
        }
        j++;
      }
    }
    node = best;
    while (node.parent && node.parent !== start) {
      node = node.parent;
    }
    deltaX1 = $gameMap.deltaX(node.x, start.x);
    deltaY1 = $gameMap.deltaY(node.y, start.y);
    if (deltaY1 > 0 && deltaX1 > 0) {
      return 3;
    } else if (deltaY1 > 0 && deltaX1 < 0) {
      return 1;
    } else if (deltaY1 < 0 && deltaX1 < 0) {
      return 7;
    } else if (deltaY1 < 0 && deltaX1 > 0) {
      return 9;
    }
    if (deltaY1 > 0) {
      return 2;
    } else if (deltaX1 < 0) {
      return 4;
    } else if (deltaX1 > 0) {
      return 6;
    } else if (deltaY1 < 0) {
      return 8;
    }
    deltaX2 = this.deltaXFrom(goalX);
    deltaY2 = this.deltaYFrom(goalY);
    if (Math.abs(deltaX2) > Math.abs(deltaY2)) {
      if (deltaX2 > 0) {
        return 4;
      } else {
        return 6;
      }
    } else if (deltaY2 !== 0) {
      if (deltaY2 > 0) {
        return 8;
      } else {
        return 2;
      }
    }
    return 0;
  };
})();

// ■ END Game_CharacterBase.coffee
//---------------------------------------------------------------------------
