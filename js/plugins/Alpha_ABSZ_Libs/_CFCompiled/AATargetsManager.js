// Generated by CoffeeScript 2.5.1
// * Менеджер по работе с целями (поиск целей, определение)
var AATargetsManager;

AATargetsManager = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AATargetsManager;
  // * Используется для определения цели для Instant NoProjectile Direction навыков
  // * Проверка точки на наличие целей для навыка
  //?[OUTER - used by AABattleActionsManager]
  //? Этот навык используется напрямую для выбора целей в битве
  _.getTargetInPoint = function(subject, aaSkill, point) {
    var events, targets;
    events = this._collectAllAAEntitiesInPoints([point]);
    if (events.isEmpty()) {
      return null;
    }
    // * В зависимости от Subject и в зависимости от действия навыка
    targets = this.filteredTargetsForSubject(subject, aaSkill, events);
    if ((targets != null) && targets.length > 0) {
      return targets[0];
    } else {
      return null;
    }
  };
  // * Отфильтровать цели (из найденных в точках) для Subject (навыка)
  _.filteredTargetsForSubject = function(subject, aaSkill, targets) {
    var candidates, e, entity, k, l, len, len1, t;
    try {
      entity = subject.AAEntity();
      candidates = [];
      if (aaSkill.isForEnemies()) {
        for (k = 0, len = targets.length; k < len; k++) {
          t = targets[k];
          if (entity.isMyEnemy(t.AAEntity())) {
            candidates.push(t);
          }
        }
      }
      if (aaSkill.isForFriends()) {
        for (l = 0, len1 = targets.length; l < len1; l++) {
          t = targets[l];
          if (!entity.isMyEnemy(t.AAEntity())) {
            candidates.push(t);
          }
        }
      }
      return candidates;
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  // * Собрать цели для навыка (Projectile)
  //?[OUTER - used by AABattleActionsManager]
  //? Этот навык используется напрямую для выбора целей в битве
  _.collectTargtesForSkill = function(subject, absSkill, point) {
    var targets;
    targets = [];
    // * Точные цели селектора, если мнгновенный навык (только для игрока)
    if (absSkill.isInstant() && ($gameTemp._aaSkillSelectorTargets != null)) {
      targets = $gameTemp._aaSkillSelectorTargets;
    } else {
      targets = this.collectTargetsForSkillInMapPoint(absSkill, point);
    }
    // * Убираем НЕ АБС события
    targets = targets.filter(function(t) {
      return t.isActive();
    });
    targets = this.filteredTargetsForSubject(subject, absSkill, targets);
    // * Сбрасываем цели селектора
    $gameTemp._aaSkillSelectorTargets = null;
    return targets;
  };
  // * Собирает все возможные цели для навыка в точке карты
  // * (Лучше использовать этот метод для определения целей)
  _.collectTargetsForSkillInMapPoint = function(aaSkill, point) {
    var kdPoint, targets;
    if (aaSkill == null) {
      return [];
    }
    if (point == null) {
      return [];
    }
    targets = [];
    if (point instanceof Game_Character && aaSkill.isSingleTargetArea()) {
      targets = [point];
    } else {
      if (aaSkill.isSingleTargetArea()) {
        targets = $gameMap.eventsXyAAExt(point.x, point.y);
      } else {
        kdPoint = new KDCore.Point(point.x, point.y);
        targets = this.collectTargetsForSkillInScreenPoint(aaSkill, kdPoint.convertToScreen());
      }
    }
    return targets;
  };
  // * Собирает все возможные цели для навыка в точке экрана
  // * (Используется для сбора событий в радиусе)
  _.collectTargetsForSkillInScreenPoint = function(aaSkill, point) {
    var searchMapPoints, targets;
    if (aaSkill == null) {
      return [];
    }
    if (point == null) {
      return [];
    }
    targets = [];
    // * Сформировать квадрат выбора
    searchMapPoints = this._createSquarePoints(aaSkill.radius, point);
    targets = this._collectAllAAEntitiesInPoints(searchMapPoints);
    return targets;
  };
  _.collectTargetsForPlayerSelector = function(aaSkill) {
    var e, targets;
    try {
      targets = this.collectTargetsForSkillInScreenPoint(aaSkill, TouchInput);
      // * Фильтр целей сразу
      return this.filteredTargetsForSubject($gamePlayer, aaSkill, targets);
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  // * Создаём точки карты в квадратной области навыка (пиксели)
  _._createSquarePoints = function(radius, point) {
    var cellSize, cellSize2, ex, ey, i, j, k, l, points, pxRadius, ref, ref1, ref2, ref3, ref4, ref5, sx, sy;
    cellSize = $gameMap.tileWidth();
    cellSize2 = cellSize / 2;
    points = [];
    pxRadius = radius * cellSize / 2;
    sx = point.x - pxRadius;
    sy = point.y - pxRadius;
    ex = point.x + pxRadius;
    ey = point.y + pxRadius;
    for (i = k = ref = sx, ref1 = ex, ref2 = cellSize; ref2 !== 0 && (ref2 > 0 ? k < ref1 : k > ref1); i = k += ref2) {
      for (j = l = ref3 = sy, ref4 = ey, ref5 = cellSize; ref5 !== 0 && (ref5 > 0 ? l < ref4 : l > ref4); j = l += ref5) {
        points.push(new KDCore.Point(i + cellSize2 / 2, j + cellSize2).convertToMap());
      }
    }
    return points;
  };
  // * Собирает все АБС сущности (события + игрок + партия)
  _._collectAllAAEntitiesInPoints = function(points) {
    var aaEntities;
    aaEntities = [];
    aaEntities.push(...this._collectAAEventsInPoints(points));
    aaEntities.push(...this._collectPartyMembersInPoints(points));
    return aaEntities;
  };
  // * Собирает все АБС события (Активные) в точках карты
  _._collectAAEventsInPoints = function(points) {
    var e, events, k, len, p;
    events = [];
    try {
      for (k = 0, len = points.length; k < len; k++) {
        p = points[k];
        events.push(...$gameMap.eventsXyAAExt(p.x, p.y));
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return events;
  };
  _._collectPartyMembersInPoints = function(points) {
    var e, k, len, members, p;
    members = [];
    try {
    //TODO: followers
    // * Сейчас только проверка на игрока
      for (k = 0, len = points.length; k < len; k++) {
        p = points[k];
        if ($gamePlayer.posExt(p.x, p.y)) {
          members.push($gamePlayer);
          break;
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return members;
  };
  // * Быстрый метод проверки, находится ли игрок в определённом радиусе
  _.isPlayerInRadius = function(point, radius) {
    var e;
    try {
      return this.isCharExtInRadius(point, radius, $gamePlayer);
    } catch (error) {
      e = error;
      AA.w(e);
      return false;
    }
  };
  // * Получить сущности в радиусе (из набора сущностей)
  _.getFilteredInRadius = function(point, radius, candidates) {
    var c, e, k, len, members;
    members = [];
    try {
      for (k = 0, len = candidates.length; k < len; k++) {
        c = candidates[k];
        if (this.isCharExtInRadius(point, radius, c)) {
          members.push(c);
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return members;
  };
  // * Находится ли персонаж (точка) в радиусе (с учётом расширенных HitBox)
  _.isCharExtInRadius = function(point, radius, char) {
    var e, k, len, p, points, x, y;
    try {
      ({x, y} = point);
      points = $gameMap.aaGetExtendedPointsFor(char);
      for (k = 0, len = points.length; k < len; k++) {
        p = points[k];
        if ($gameMap.distance(x, y, p.x, p.y) <= radius) {
          return true;
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return false;
  };
  // * Получить дистанцию между персонажем и точкой (на экране)
  // * Учитываются расширенные HitBox
  _.getScreenExtDistance = function(char, offsetY, x2, y2) {
    var dist, e, k, l, len, len1, screenXs, screenYs, x, y;
    try {
      if (char == null) {
        return 1000;
      }
      if (char.aaIsHaveExtendedHitBoxes()) {
        screenXs = char.screenXExt();
        screenYs = char.screenYExt();
        dist = [];
        for (k = 0, len = screenXs.length; k < len; k++) {
          x = screenXs[k];
          for (l = 0, len1 = screenYs.length; l < len1; l++) {
            y = screenYs[l];
            dist.push(AA.Utils.Math.getXYDistance(x, y - offsetY, x2, y2));
          }
        }
        return dist.min();
      } else {
        return AA.Utils.Math.getXYDistance(char.screenX(), char.screenY() - offsetY, x2, y2);
      }
    } catch (error) {
      e = error;
      AA.w(e);
      return 1000;
    }
  };
  // * Цель подходящая (проверки, см. BattleManagerABS.isValidTarget)
  //TODO: isValidTarget
  _.isValidTarget = function(char, targetChar) {
    return true;
  };
  // * Находится ли точка (цель) в области дейтсвия навыка (range)
  _.isInSkillRange = function(char, skillId, targetPoint) {
    var dataObj, dist, e, skill;
    try {
      //TODO: ПОка просто
      dist = char.distTo(targetPoint);
      dataObj = AA.Utils.getAASkillObject(skillId);
      skill = dataObj.AASkill;
      //console.log("D " + dist)
      //console.log("R " + skill.range)
      return dist <= skill.range;
    } catch (error) {
      e = error;
      AA.w(e);
      return false;
    }
  };
  // * Получить всех ботов, которые имеют игрока своей целью
  //TODO: TeamID учёт
  // * На данный момент не проверяется кто именно цель, так как нету сопартийцев и teamId
  _.getAllWhoHavePlayerAsTarget = function() {
    return $gameMap.eventsAA().filter(function(e) {
      return e.AAEntity().isHasTarget();
    });
  };
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------
