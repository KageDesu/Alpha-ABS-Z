// Generated by CoffeeScript 2.5.1
(function() {
  var Sprite_SelectedCircle;
  
    // * Спрайт - круг на карте под выбранной целью
  Sprite_SelectedCircle = class Sprite_SelectedCircle extends KDCore.Sprite {
    constructor() {
      super();
      this.bitmap = this.defaultCircle();
      this.anchor.set(0.5);
      // * Изначально не видимый
      this.visible = false;
    }

    isActive() {
      return this.visible === true;
    }

    // * Установить цель (показать круг и переместить к цели)
    setTarget(char) {
      if ((char != null) && char.isABS()) {
        return this._linkToTarget(char);
      } else {
        return this._reset();
      }
    }

    resetTarget() {
      return this.setTarget(null);
    }

    defaultCircle() {
      return ImageManager.loadAA(this.defaultSettings().selectionImage);
    }

    //TODO: Учёт начальной видимости
    //TODO: Это из plugin parameters
    defaultSettings() {
      return {
        visible: true,
        selectionImage: "targetSelectedCircle",
        margins: {
          x: 0,
          y: 0
        },
        animation: true // * Это касается мерцания
      };
    }

    update() {
      super.update();
      return this._updateMain();
    }

  };
  AA.link(Sprite_SelectedCircle);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_SelectedCircle.prototype;
  _._reset = function() {
    this._updateMain = function() {};
    this.move(-100, -100);
    this.visible = false;
    this._deleteHpGauge();
  };
  _._linkToTarget = function(char) {
    var e;
    try {
      this.visible = false;
      this._targetSpr = char.AASprite();
      this._charSettings = char.AAEntity().model();
      //TODO: Определять видимость из параметров
      this._determineTargetColor(char);
      this._determineTargetImage();
      this._updateMain = this._updateWithTarget;
      if (this.defaultSettings().animation === true) {
        this._createOpacityChanger();
      }
      return this._updateWithTarget();
    } catch (error) {
      //TODO: TEMP
      //@_createHPMiniBar()
      e = error;
      KDCore.warning(e);
      return this._reset();
    }
  };
  _._createOpacityChanger = function() {
    this.changer = new AA.Changer(this);
    this.changer.change('opacity').from(255).to(150).step(5).reverse().repeat().start();
    this._updateOpacityEffect = () => {
      return this.changer.update();
    };
  };
  //?DYNAMIC
  _._updateMain = function() {}; // * EMPTY
  
  // * Перемещение к позиции цели
  _._updateWithTarget = function() {
    var e;
    this.move(this._targetSpr.x, this._targetSpr.y);
    try {
      if ((this._charSettings != null) && (this._charSettings.selectionOffset != null)) {
        this.x += this._charSettings.selectionOffset[0];
        this.y += this._charSettings.selectionOffset[1];
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return this._updateOpacityEffect();
  };
  //?DYNAMIC
  _._updateOpacityEffect = function() {}; // * EMPTY
  
  // * Определить какой цвет установить
  _._determineTargetColor = function(char) {
    var e;
    try {
      if ((this._charSettings != null) && String.any(this._charSettings.selectionColor)) {
        this._applyCustomColor(this._charSettings.selectionColor);
        return;
      }
      if (char.AABattler().isActor()) {
        this._applyAllyColor();
      } else {
        if ($gamePlayer.isMyEnemy(char)) {
          this._applyEnemyColor();
        } else {
          this._applyNetralColor();
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this._applyUnknownColor();
    }
  };
  // * Определяет какую картинку выделения использовать
  _._determineTargetImage = function() {
    var e;
    try {
      if ((this._charSettings != null) && String.any(this._charSettings.selectionImage)) {
        this.bitmap = ImageManager.loadAA(this._charSettings.selectionImage);
      } else {
        this.bitmap = this.defaultCircle();
      }
      this.bitmap.addLoadListener(() => {
        return this.visible = true;
      });
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  // * Цвет, когда выбран враг
  _._applyEnemyColor = function() {
    return this.setBlendColor(KDCore.Color.RED.ARR);
  };
  // * Когда выбран член партии
  _._applyAllyColor = function() {
    return this.setBlendColor(KDCore.Color.GREEN.ARR);
  };
  // * Когда выбран монстр с teamId == 0
  _._applyNetralColor = function() {
    return this.setBlendColor(KDCore.Color.AQUA.ARR);
  };
  // * В случае ошибки
  _._applyUnknownColor = function() {
    return this.setBlendColor(KDCore.Color.YELLOW.ARR);
  };
  
  // * Из настроек цели
  _._applyCustomColor = function(color) {
    var c;
    c = KDCore.Color.FromHex(color);
    return this.setBlendColor(c.ARR);
  };
  _._createHPMiniBar = function() {
    var data, hpBar, p;
    //TODO: Тут полный бардак, плюс этот метод не тут должен быть вообще!
    // * Сделано только для показа
    // Надо HP на спрайте отрисовывать
    this._deleteHpGauge();
    data = "miniHpGauge1";
    if (String.any(this._charSettings.miniHpGaugeStyle)) {
      data = this._charSettings.miniHpGaugeStyle;
    }
    p = AA.PP.uiData(data);
    p.position.x = this.x - 28;
    p.position.y = this.y - 62;
    if (this._charSettings.miniHPGaugeOffset != null) {
      p.position.x += this._charSettings.miniHPGaugeOffset[0];
      p.position.y += this._charSettings.miniHPGaugeOffset[1];
    }
    hpBar = new AA.Sprite_ActorStateGauge(p);
    this.parent.addChild(hpBar);
    return this.hpGauge = hpBar;
  };
  _._deleteHpGauge = function() {
    if (this.hpGauge != null) {
      return this.parent.removeChild(this.hpGauge);
    }
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------
