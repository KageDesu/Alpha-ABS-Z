// Generated by CoffeeScript 2.5.1
// * Состояние (машина) для врага в битве
var EnemyAI_BattleFlow;

EnemyAI_BattleFlow = class EnemyAI_BattleFlow extends AIFlow {
  constructor() {
    super(...arguments);
    return;
  }

  target() {
    return this.entity().getTarget();
  }

  onStateStart() {
    "IN BATTLE STATE".p();
    // * Таймер следующей выборки действия
    // * Когда действие было выбранно, идёт небольшая пауза
    // * перед следующей выборкой действия
    this._nextActionCheck = 0;
    // *
    this._canFightNow = true;
    // * Бот отступает из боя
    this._fleeFromBattle = false;
  }

  //TODO: change move type
  //TEMP: остановлю ботика
  //@char()._moveType = 0
  //@char().aaSetMoveTypeKeepBattleDistance()
  //TODO: filter skills
  onStateEnd() {
    //on char сделать метод основной
    this.entity().resetBattle();
    //TODO: clear target and other stuff (onBattleEnd for battle etc)
    return "BATTLE END".p();
  }

};

(function() {  // * onStateEnd нету, так как Free состояние базовое

  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ EnemyAI_BattleFlow.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = EnemyAI_BattleFlow.prototype;
  _._setup = function() {};
  
  //TODO: ЕСТЬ БАГ, если убить одного врага, другие не хотят сражаться, остаюстя в keep
  _._updateFlow = function() {
    if (this._canFightNow === true) {
      this._updateOutOfHomeFlow();
      return this._updateBattleFlow();
    } else {
      return this._updateFleeFlow();
    }
  };
  // * Если отошёл слишком далеко от "дома", надо вернуться
  _._updateOutOfHomeFlow = function() {
    if (this._isTooFarFromHomePoint()) {
      return this._canFightNow = false;
    }
  };
  _._isTooFarFromHomePoint = function() {
    var homePoint;
    homePoint = this.char().homePoint;
    if (homePoint == null) {
      return false;
    }
    return this.char().distTo(homePoint) > (this.model().returnRadius);
  };
  _._updateBattleFlow = function() {
    if (this._isTargetValid()) {
      this._selectActionToUse();
      if (this._isActionIsExists()) {
        if (this._isActionInDistance()) {
          return this._executeAction();
        } else {
          return this._movingCloserToTarget();
        }
      } else {
        return this._waitForAction();
      }
    } else {
      return this.logic().switchToFreeState();
    }
  };
  _._isTargetValid = function() {
    return this._isTargetInViewRadius() && AATargetsManager.isValidTarget(this.char(), this.target());
  };
  //TODO: Сделать параметр SeekTime - когда цель вне видимости, какой-то время (в сек) всё равно преследовать
  // * или следовать в точку где последний раз видел
  // * Можно отдельное состояние (поиск по маршруту или случайно)
  // * Объеденить с системой слышымости (по сути это и есть - движение к источнику звука и патруль)
  _._isTargetInViewRadius = function() {
    return this.char().distTo(this.target()) <= (this.model().viewRadius + 1);
  };
  _._selectActionToUse = function() {
    var skills;
    this._nextActionCheck--;
    if (this._nextActionCheck > 0) {
      return;
    }
    //TODO: алгоритм выбора действия для использования сейчас
    skills = this.battler().getUsableAASkills();
    if (skills.length > 0) {
      if (skills.length === 1) {
        this._setCurrentAction(skills[0]);
      } else {
        this._selectBetterActionForNow(skills);
      }
    } else {
      this._resetCurrentAction();
    }
  };
  _._setCurrentAction = function(_currentAction) {
    this._currentAction = _currentAction;
    //TODO: Надо это или нет?
    return this._nextActionCheck = 20;
  };
  _._selectBetterActionForNow = function(skills) {
    //TODO: Все навыки применить testApply и выбрать лучший + тот который
    // можно использовать без подхода к цели
    //TODO: пока просто первый возвращаем
    this._setCurrentAction(skills.first());
  };
  _._resetCurrentAction = function() {
    this._currentAction = null;
    this._nextActionCheck = 0;
  };
  _._isActionIsExists = function() {
    return this._currentAction != null;
  };
  // * Находится ли цель на расстроянии применения действия
  _._isActionInDistance = function() {
    var aaSkill;
    aaSkill = this._currentAction.AASkill;
    if (aaSkill.isSelfAction()) {
      // * Если для врагов, то проверим, что враг в области radius действия навыка
      if (aaSkill.isForEnemies()) {
        return AATargetsManager.isCharExtInRadius(this.char(), aaSkill.radius, this.target());
      } else {
        return true;
      }
    } else {
      // * range <= 1 тут используется, чтобы монстр мог ударить диагонально, но не больше 1 клетки
      if (aaSkill.isInPoint() || aaSkill.range <= 1) {
        return AATargetsManager.isCharExtInRadius(this.char(), aaSkill.range, this.target());
      } else {
        // * Пока просто проверка расстояния
        //range = aaSkill.range
        //TODO: * Цель должна быть передо мной (на прямом направлении)
        // (см. inDirectionHard в Alpha ABS)
        return AATargetsManager.isCharExtInRadius(this.char(), aaSkill.range, this.target());
      }
    }
  };
  _._executeAction = function() {
    var char, e;
    try {
      //TODO: Custom Attack Move Route
      "EXECUTE".p();
      //TODO: EXECUTE ACITON !!!
      // * Дополнительная проверка ещё раз перед выполнением действия
      // * Это нужно, потому что АИ выбирает очередное действие после выбора через время
      // * см. @_nextActionCheck
      if (!this.battler().canUse(this._currentAction)) {
        return this._resetCurrentAction();
      } else {
        "EEXECUTGE".p();
        char = this.char();
        char.setActiveAASkill(this._currentAction.idA);
        return char.startPerformAASkill($gamePlayer);
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _._movingCloserToTarget = function() {
    "APPROACH".p();
    return this.char().aaSetMoveTypeApproachTarget();
  };
  _._waitForAction = function() {
    "KEEP ".p();
    this.char().aaSetMoveTypeKeepBattleDistance();
  };
  // * Враг возвращается (отступает) к точке дом
  // * Пока не увидит дом (в View Radius)
  // * В отличии от Free State, точка дома не меняется, поэтому враг получается
  // * всегда будет держаться своего "дома" и сражаться в определённом радиусе
  //TODO: Custom Move Route?
  // * Задать параметр, чтобы АИ выполнял в бою customMoveRoute если нет навыков
  _._updateFleeFlow = function() {
    "FLEE".p();
    if (this.char().distTo(this.char().homePoint) <= (this.model().viewRadius - 1)) {
      this._canFightNow = true;
    } else {
      this.char().aaSetMoveTypeReturnToHomePoint();
    }
  };
})();

// ■ END EnemyAI_BattleFlow.coffee
//---------------------------------------------------------------------------
