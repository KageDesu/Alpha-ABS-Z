// Generated by CoffeeScript 2.5.1
//TODO: Систематизация класса
var UITargetInfoController;

UITargetInfoController = class UITargetInfoController {
  constructor(targetInfoSpr) {
    this.targetInfoSpr = targetInfoSpr;
    AA.EV.subscribeFor("UnderMouseEventChanged", this.gev_onUnderMouseEventChanged.bind(this));
    this._createSoControllers();
    this.targetInfoSpr.visible = false;
    return;
  }

  refresh() {
    return this.gev_onUnderMouseEventChanged();
  }

  setup(target) {
    this.target = target;
    if (this.target == null) {
      this.hideTargetInfo();
    }
    this.gaugeCnt.setup(this.target.AABattler(), "hp", "mhp");
    this.showTargetInfo();
  }

  hideTargetInfo() {
    this.targetInfoSpr.hideSlow();
    this.target = null;
  }

  showTargetInfo() {
    var battler, model;
    model = this.target.AAEntity().model();
    if (model.UIInfo === 0) {
      return;
    }
    battler = this.target.AABattler();
    //TODO: Values from enemy
    this.targetInfoSpr.drawNameWithFormat(battler.name());
    //TODO: level from what?
    this.targetInfoSpr.drawLevelWithFormat(1);
    this.targetInfoSpr.drawFace(model.faceName, model.faceIndex);
    //TODO: battle state show and refresh by AI state
    this.targetInfoSpr.showSlow();
  }

  update() {
    if (!this.targetInfoSpr.visible) {
      return;
    }
    this.gaugeCnt.update();
  }

  gev_onUnderMouseEventChanged() {
    if ($gameTemp._aaEventUnderCursor != null) {
      if (this.target !== $gameTemp._aaEventUnderCursor) {
        this.setup($gameTemp._aaEventUnderCursor);
      }
    } else {
      this.hideTargetInfo();
    }
  }

  _createSoControllers() {
    this.gaugeCnt = new AA.GaugeController(this.targetInfoSpr.gauge);
    // * Используется свой метод для отрисовки значения (с форматом)
    this.gaugeCnt.targetInfoSpr = this.targetInfoSpr;
    this.gaugeCnt._refreshValues = function() {
      var rate;
      rate = this.value / this.max;
      this.gaugeSprite.drawGauge(rate);
      return this.targetInfoSpr.drawHpWithFormat(this.value, this.max, rate);
    };
  }

};
