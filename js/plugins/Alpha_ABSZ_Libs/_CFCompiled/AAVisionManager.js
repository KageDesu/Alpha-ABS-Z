// Generated by CoffeeScript 2.5.1
// * Менеджер по работе с визорами АИ
var AAVisionManager;

AAVisionManager = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AAVisionManager;
  // * Проверка видимости между визором (событием) и точкой (TRUE - видно точку)
  _.isVisionLineIsFree = function(visor, endPoint) {
    var allPoints, betweenPoints, dist, e, eP, j, l, len, len1, p, sP;
    try {
      dist = $gameMap.distance(visor.x, visor.y, endPoint.x, endPoint.y);
      if (dist <= 1) {
        // * Если дистанция 1 (рядом), то значит на линии видимости не может быть помех
        return true;
      }
      // * Количество точек проверок на линии
      // * Хватит точности 1 к 1, поэтому количество точек = дистанции
      allPoints = this.getLineBetweenTwoPoints(visor, endPoint, dist);
      betweenPoints = [];
      // * Убираем End и Start точки с результата
      // * Нам важно проверить путь между начальной и конечной точкой
      sP = [visor.x, visor.y];
      eP = [endPoint.x, endPoint.y];
      for (j = 0, len = allPoints.length; j < len; j++) {
        p = allPoints[j];
        if (!AA.Utils.isSamePointA(p, sP) && !AA.Utils.isSamePointA(p, eP)) {
          betweenPoints.push(p);
        }
      }
      if (betweenPoints.length === 0) {
        
        // * Если между нет точек, то значит на линии видимости
        return true;
      }
      console.log(betweenPoints);
      for (l = 0, len1 = betweenPoints.length; l < len1; l++) {
        p = betweenPoints[l];
        // * Если в точке находится объект (зона), что мешает зрению, значит false
        if (this.isPointIsColiderForVision(visor, p[0], p[1])) {
          return false;
        }
      }
      return true;
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return false;
  };
  // * Возвращает линию из точек между начальной и конечной точкой (включая начальную и конечную)
  _.getLineBetweenTwoPoints = function(startPoint, endPoint, precission) {
    var cpx, cpy, e, eX, eY, i, j, k, points, px, py, ref, sX, sY, tw;
    try {
      tw = $gameMap.tileWidth();
      sX = Number(startPoint.x * tw + tw / 2);
      sY = Number(startPoint.y * tw + tw / 2);
      eX = Number(endPoint.x * tw + tw / 2);
      eY = Number(endPoint.y * tw + tw / 2);
      points = [];
      for (i = j = 1, ref = precission; (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {
        k = i / precission;
        px = k * (eX - sX) + sX;
        py = k * (eY - sY) + sY;
        cpx = Math.floor(px / $gameMap.tileWidth());
        cpy = Math.floor(py / $gameMap.tileHeight());
        points.push([cpx, cpy]);
      }
      return points;
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return [];
  };
  // * Находится ли в данной точке карты что-либо, что мешает видимости
  // * TRUE - нельзя "видеть" через эту точку
  _.isPointIsColiderForVision = function(visor, x, y) {
    var e, events, noVisionRegions, noVisionTerrains;
    try {
      noVisionRegions = AA.PP.getVisionRestrictedRegions();
      noVisionTerrains = AA.PP.getVisionRestrictedTerrains();
      if (noVisionRegions.contains($gameMap.regionId(x, y))) {
        return true;
      }
      if (noVisionTerrains.contains($gameMap.terrainTag(x, y))) {
        return true;
      }
      // * События с расширенными HitBox участвуют в области видимости
      events = $gameMap.eventsXyExt(x, y);
      if (events.isEmpty()) {
        return false;
      }
      // * Если хоть один блокирует, то значит заблокирована видимость
      return events.some(function(e) {
        return e.aaIsBlockVision();
      });
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return true;
  };
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------
