// Generated by CoffeeScript 2.6.1
// * Класс с методами взаимодействия навыков и Entities (аналог Battle Process)
var AABattleActionsManager;

AABattleActionsManager = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AABattleActionsManager;
  _.startAASkill = function(aaSkill, subject, targetPoint) {
    var direction, i, j, nextPoint, ref, target;
    if (aaSkill == null) {
      return;
    }
    if (aaSkill.isSelfAction()) {
      "SELF ACTION".p();
      this.applySkillAction(subject, subject, aaSkill);
    } else if (aaSkill.isInstant()) {
      "INSTANT ACTION".p();
      // * Надо получить точку по направлению
      if (!aaSkill.isInPoint()) {
        nextPoint = subject;
        direction = subject.direction();
        for (i = j = 1, ref = aaSkill.range; (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {
          nextPoint = AA.Utils.Math.getProjectilePointByDirection(nextPoint, direction);
          target = AATargetsManager.getTargetInPoint(subject, aaSkill, nextPoint);
          if (target == null) {
            // * Если цели нет, просто передаём точку на карте (для NoContact навыков)
            target = nextPoint;
          }
          this.applySkillAction(subject, target, aaSkill);
        }
      } else {
        this.applySkillAction(subject, targetPoint, aaSkill);
      }
    } else {
      $gameMap.startAASkill(aaSkill, subject, targetPoint);
    }
  };
  
  // * Выполнение действия АБС навыка на карте или Entity
  _.applySkillAction = function(subject, target, absSkill) {
    var animationId, e, targets, x, y;
    try {
      "applySkillAction".p();
      animationId = this.getProperAnimationId(subject, absSkill);
      if (target instanceof Game_Character) {
        if (absSkill.animationOnMap === 0) {
          this.playAnimationOnCharacter(target, animationId);
        } else {
          this.playAnimationOnMap(target.x, target.y, animationId);
        }
      } else {
        // * Если навык требует контакт, то нет никаких эффектов
        if (!absSkill.isNoContact()) {
          return;
        }
        ({x, y} = target);
        this.playAnimationOnMap(x, y, animationId);
      }
      targets = AATargetsManager.collectTargtesForSkill(subject, absSkill, target);
      this.performBattleAction(subject, absSkill, targets);
    } catch (error) {
      //TODO: Do Common Action (Выполнение обычных действий на событиях или персонажах)
      e = error;
      AA.w(e);
    }
  };
  //TODO: Добавить параметр Animation Scalling ??? Чтобы скалировать обычную анимацию на карте и не переделывать каждую

  // * Анимация с учётом оружия
  _.getProperAnimationId = function(subject, absSkill) {
    var animationId, e;
    try {
      animationId = absSkill.animationId();
      if (animationId === -1) { // * Normal attack
        return subject.AABattler().attackAnimationId1();
      }
      //TODO: attackAnimationId2 if dual weild
      return animationId;
    } catch (error) {
      e = error;
      AA.w(e);
      return 0;
    }
  };
  //TODO: [Идея] Проигрывание анимации на всём экране или в координатах экрана

  // * Воспроизвести анимацию на персонаже
  _.playAnimationOnCharacter = function(char, animationId) {
    var e;
    try {
      if ((animationId != null) && animationId > 0) {
        AANetworkManager.playAnimationOnCharacter(char, animationId);
        $gameTemp.requestAnimation([char], animationId, false);
      }
    } catch (error) {
      e = error;
      KDCore.warning("playAnimationOnCharacter", e);
    }
  };
  // * Воспроизвести анимацию в точке на карте
  _.playAnimationOnMap = function(x, y, animationId) {
    var e;
    if (!KDCore.Utils.isSceneMap()) {
      return;
    }
    try {
      if ((animationId != null) && animationId > 0) {
        AANetworkManager.playAnimationOnMap(x, y, animationId);
        $gameMap.aaRequestMapAnimation(x, y, animationId);
      }
    } catch (error) {
      e = error;
      KDCore.warning("playAnimationOnMap", e);
    }
  };
  // * ======================================================================
  // * BATTLE ACTION LOGIC

  // * subject и target - это characters, не battlers
  _.performBattleAction = function(subject, skill, targets) {
    var action, e;
    "PERFORM BATTLE ACTION".p();
    "SUB".p();
    console.info(subject);
    "SKILL".p();
    console.info(skill);
    "TARG".p();
    console.info(targets);
    if (subject == null) {
      return;
    }
    if (skill == null) {
      return;
    }
    try {
      action = new AABattleAction(subject, skill);
      if (!action.isValid()) {
        return;
      }
      this._startAction(action, targets);
      this._endAction(action);
    } catch (error) {
      e = error;
      KDCore.warning("performBattleAction", e);
    }
  };
  _._startAction = function(action, targets) {
    var e, j, len, t;
    try {
      // * Вызов общих событий навыка (предмета)
      //TODO: Вызов общих событий AASkill ???
      action.applyGlobal();
      for (j = 0, len = targets.length; j < len; j++) {
        t = targets[j];
        this._invokeAction(t, action);
      }
    } catch (error) {
      e = error;
      KDCore.warning("_startAction", e);
    }
  };
  _._invokeAction = function(target, action) {
    var e;
    try {
      //TODO: Возможно Drain с текущим алгоритмом работать не будут
      // * Сейчас каждый игрок отправляет свой Observer, т.е. нельзя
      // * изменить значение HP персонажа на другом клиенте, надо
      // * вызывать метод, который меняет на текущем клиенте (собственнике персонажа)
      if (AA.Network.isNetworkGame()) {
        if (target instanceof Game_Event) {
          if (ANGameManager.isMapMaster()) {
            this._applyActionOnTarget(target, action);
          } else {
            AANetworkManager.applyActionOnTarget(target, action);
          }
        } else if (target instanceof NETCharacter) {
          AANetworkManager.applyActionOnTarget(target, action); // * Game_Player (SELF)
        } else {
          this._applyActionOnTarget(target, action);
        }
      } else {
        this._applyActionOnTarget(target, action);
      }
    } catch (error) {
      e = error;
      KDCore.warning("_invokeAction", e);
    }
  };
  _._applyActionOnTarget = function(target, action) {
    var e;
    try {
      if (action == null) {
        return;
      }
      if (target == null) {
        return;
      }
      //TODO: repeats time?
      //TODO: CE on Use
      //TODO: Impulse?
      action.apply(target);
      this._onActionResult(target, action);
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  _._onActionResult = function(target, action) {
    var battler, e;
    try {
      battler = target.AABattler();
      if (!battler.result().used) {
        return;
      }
      this._performActionResultOnTarget(target);
      battler.startDamagePopup();
      action.subject().startDamagePopup();
      target.aaOnActionOnMe(action);
    } catch (error) {
      e = error;
      KDCore.warning("_onActionResult", e);
    }
  };
  // * Звуковые и визуальные эффекты после действия (на цели)
  _._performActionResultOnTarget = function(target) {
    var battler, e, result;
    try {
      battler = target.AABattler();
      result = battler.result();
      // * MISS
      if (result.missed) {
        battler.performMiss();
      // * EVADE
      } else if (result.evaded) {
        if (result.physical) {
          battler.performEvasion();
        } else {
          battler.performMagicEvasion(); // * DAMAGE
        }
      } else {
        // * HP
        if (result.hpAffected) {
          if (result.hpDamage > 0 && !result.drain) {
            battler.performDamage();
          }
          if (result.hpDamage < 0) {
            battler.performRecovery();
          }
        }
        // * MP and TP
        if (battler.isAlive() && (result.mpDamage !== 0 || result.tpDamage !== 0)) {
          if (result.mpDamage < 0 || result.tpDamage < 0) {
            battler.performRecovery();
          }
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning("_actionResultOnDamage", e);
    }
  };
  //TODO: Надо каждую секунду вызывать battler.onTurnEnd ???
  _._endAction = function(action) {
    var battler, e;
    try {
      battler = action.subject();
      battler.onAAActionEnd();
    } catch (error) {
      e = error;
      KDCore.warning("_endAction", e);
    }
  };
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------
