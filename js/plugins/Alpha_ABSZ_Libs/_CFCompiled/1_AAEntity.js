// Generated by CoffeeScript 2.6.1
// * Основной класс объекта АБС на карте (монстр, игрок и т.д.)

//@[STORABLE]
//@[GLOBAL]
var AAEntity;

AAEntity = class AAEntity {
  constructor() {
    this._setup();
    if (AA.Network.isNetworkGame()) {
      this._setupForNetwork();
    }
  }

  _setup() {
    this._active = false;
    this._target = null;
    this._dead = false;
    // * Состояние
    return this._state = null;
  }

  // * UPDATE
  // -----------------------------------------------------------------------
  update() {}

  // * ABS
  // -----------------------------------------------------------------------
  initABS() {
    return this.activate();
  }

  // * PROPERTIES
  // -----------------------------------------------------------------------
  teamId() {
    return 0;
  }

  character() {}

  battler() {}

  sprite() {
    return $gameMap.spriteset().findTargetSprite(this.character());
  }

  logic() {
    return null;
  }

  // * HELPERS
  // -----------------------------------------------------------------------
  isMyEnemy(aaEntity) {
    if (aaEntity == null) {
      return false;
    }
    if (!aaEntity.isActive()) {
      return false;
    }
    return aaEntity.teamId() !== this.teamId();
    return false;
  }

  // * Эти поля используются для опеределения типа дочернего класса
  isPlayer() {
    return false;
  }

  isAlly() {
    return false;
  }

  isNetChar() {
    return false;
  }

  isEnemy() {
    return false;
  }

  // * TARGET
  // -----------------------------------------------------------------------
  setTarget(target) {
    return this._target = AA.Utils.packAAEntity(target);
  }

  resetTarget() {
    return this.setTarget(null);
  }

  getTarget() {
    return AA.Utils.unpackAAEntity(this._target);
  }

  isHasTarget() {
    return this._target != null;
  }

  
    // * MAIN STATE
  // -----------------------------------------------------------------------
  isActive() {
    return this._active === true;
  }

  activate() {
    return this._active = true;
  }

  deactivate() {
    return this._active = false;
  }

  // * BATTLE STATE
  // -----------------------------------------------------------------------
  // * Зависит от наличия цели
  inBattle() {
    return this.isHasTarget();
  }

  resetBattle() {
    return this.resetTarget();
  }

  // * DEAD STATE
  // -----------------------------------------------------------------------
  isDead() {
    return this._dead === true;
  }

  setDead() {
    return this._dead = true;
  }

  resetDead() {
    return this._dead = false;
  }

  // * NETWORK
  // -----------------------------------------------------------------------
  _setupForNetwork() {
    return this._createNetworkObserver();
  }

  //TODO: Возможно нужен Instant режим?
  _createNetworkObserver() {
    this.netDataObserver = new DataObserver();
    this.netDataObserver.setCheckInterval(ANET.PP.playerDataRefreshRate());
    this._fillNetworkObserver();
    this.netDataObserver.refreshAll(this);
  }

  _fillNetworkObserver() {
    this.netDataObserver.addFields(this, ["_target", "_active"]);
  }

  updateDataObserver() {
    if (this.netDataObserver == null) {
      return;
    }
    this.netDataObserver.check(this);
    if (this.netDataObserver.isDataChanged()) {
      this.dataObserverHaveChanges();
      this.netDataObserver.refreshAll(this);
    }
  }

  // * Этот метод вызывается, когда изменились сихнронизируеммые данные
  dataObserverHaveChanges() {
    AANetworkManager.syncAAEntityObserver(this.character(), this.getObserverDataForNetwork());
  }

  getObserverDataForNetwork() {
    var data;
    data = this.netDataObserver.getDataForNetwork(this);
    return data;
  }

  applyObserverData(data) {
    if (this.netDataObserver == null) {
      return;
    }
    this.netDataObserver.setDataFromNetwork(this, data);
  }

};
