// Generated by CoffeeScript 2.5.1
// * Класс для показа полоски здоровья над персонажами на карте
// * Имеет свой встроенный контроллер
(function() {
  var Sprite_CharacterMiniGauge;
  //rev 30.06.2021
  Sprite_CharacterMiniGauge = class Sprite_CharacterMiniGauge extends AA.Sprite_UIElement {
    constructor() {
      super(...arguments);
      // * По умолчанию нету доп. смещения
      // * (у каждого события может быть своё, это см. в Model)
      this.setExtraMargins(0, 0);
      return;
    }

    setupController(battler, rateGetter) {
      this.battler = battler;
      this.rateGetter = rateGetter;
      // * Если изначально в параметрах visible == false, то ничего
      if (!this.isActive()) {
        return;
      }
      this.visible = this.battler != null;
      this.controllerThread = new KDCore.TimedUpdate(10, this.refreshValues.bind(this));
    }

    defaultParams() {
      return {
        visible: true,
        position: {
          x: -19,
          y: -56
        },
        label: null,
        labelMargins: {
          x: 0,
          y: 0
        },
        // * TEXT не используется в этой реализации
        text: {
          visible: false,
          size: {
            w: 100,
            h: 20
          },
          alignment: "left",
          font: {
            face: "AABS_0",
            size: 13,
            italic: false
          },
          margins: {
            x: 10,
            y: 0
          },
          outline: {
            color: null,
            width: 2
          },
          textColor: "#edead8".toCss()
        },
        gauge: {
          visible: true,
          fill: "Event_HPGauge2",
          foreground: "",
          mask: "",
          backColor: "#000000".toCss(),
          backOpacity: 160,
          vertical: false
        }
      };
    }

    setExtraMargins(dx, dy) {
      this.dx = dx;
      this.dy = dy;
    }

    refreshPosition(x, y) {
      // * Настройки сперва (смещение)
      this._resetPosition();
      // * Затем координаты на экране
      this.x += x;
      this.y += y;
      // * Теперь дополнительные настройки
      this.x += this.dy;
      this.y += this.dy;
    }

    showInstant() {
      return this.visible = true;
    }

    showSlow() {
      if (this.visible === true && this.opacity >= 255) {
        return;
      }
      this.refreshValues();
      this.visible = true;
      this.changer = new AA.Changer(this);
      this.changer.change('opacity').from(0).to(255).step(35).start();
      this.showHideThread = null;
    }

    hideInstant() {
      return this.visible = false;
    }

    hideSlow() {
      if (this.visible === false) {
        return;
      }
      if (this.showHideThread != null) {
        return;
      }
      if (this.opacity <= 0) {
        return;
      }
      this.changer = new AA.Changer(this);
      this.changer.change('opacity').from(this.opacity).to(0).step(45).start().done(() => {
        return this.visible = false;
      });
    }

    showAndHide() {
      if (this.visible === true) {
        return;
      }
      if (this.showHideThread != null) {
        return;
      }
      this.showSlow();
      this.showHideThread = new KDCore.TimedUpdate(60, this._hideAfterTime.bind(this));
      this._updateShowHide = this._updateShowHideBody;
    }

    drawGauge(percent) {
      return this.gauge.draw(percent);
    }

    drawText(text) {
      return this.text.draw(text);
    }

    //TODO: Динамическую смену
    refreshValues() {
      var newRate;
      if (this.__prevRate == null) {
        this.__prevRate = this.battler[this.rateGetter]();
        this.drawGauge(this.__prevRate);
      } else {
        newRate = this.battler[this.rateGetter]();
        //TODO: animated?
        //if newRate < @__prevRate
        //    diff = @__prevRate - newRate
        if (newRate !== this.__prevRate) {
          this.__prevRate = newRate;
          this.drawGauge(newRate);
        }
      }
    }

    update() {
      var ref;
      super.update();
      this._updateController();
      this._updateShowHide();
      if ((ref = this.changer) != null) {
        ref.update();
      }
    }

  };
  AA.link(Sprite_CharacterMiniGauge);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ Sprite_CharacterMiniGauge.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_CharacterMiniGauge.prototype;
  //$[OVER]
  _._createContent = function() {
    this._createGauge();
    this._createText();
    this._createLabel();
    return this.move(this.params.position);
  };
  _._createGauge = function() {
    this.gauge = new AA.Sprite_UIGauge(this.params.gauge);
    return this.add(this.gauge);
  };
  _._createText = function() {
    this.text = new AA.Sprite_UIText(this.params.text);
    return this.add(this.text);
  };
  _._createLabel = function() {
    var label;
    if (String.isNullOrEmpty(this.params.label)) {
      return;
    }
    label = new AA.Sprite_UIImage();
    label.draw(this.params.label);
    label.move(this.params.labelMargins);
    return this.add(label);
  };
  _._updateController = function() {
    if (!this.isActive()) {
      return;
    }
    if (this.battler == null) {
      return;
    }
    return this.controllerThread.update();
  };
  _._hideAfterTime = function() {
    this.showHideThread = null;
    return this.hideSlow();
  };
  //?DYNAMIC
  _._updateShowHide = function() {}; // * EMPTY
  _._updateShowHideBody = function() {
    var ref;
    return (ref = this.showHideThread) != null ? ref.update() : void 0;
  };
})();

// ■ END Sprite_CharacterMiniGauge.coffee
//---------------------------------------------------------------------------
